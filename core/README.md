# Core Module - Детальная документация

Модуль `core` представляет собой фундаментальную основу всего приложения X-RouterSBC. Думайте о нем как о центральной нервной системе, которая координирует работу всех остальных компонентов системы. Давайте разберем каждый аспект этого модуля пошагово, чтобы понять, как он обеспечивает надежную и масштабируемую архитектуру.

## Архитектурная философия

Модуль `core` построен на принципе инверсии управления и автозагрузки компонентов. Это означает, что вместо жесткого кодирования зависимостей, система автоматически обнаруживает и регистрирует обработчики, маршруты и модули. Такой подход обеспечивает гибкость разработки и упрощает масштабирование системы.

## Структура файлов модуля

```
core/
├── server.go          # Основной HTTP сервер и конфигурация Echo
├── websocket.go       # WebSocket менеджер для real-time коммуникации
├── auth.go           # Система аутентификации и авторизации  
├── database.go       # Менеджер SQLite базы данных
├── loader.go         # Автозагрузчик модулей и компонентов
├── middleware.go     # Промежуточные обработчики запросов
├── config.go         # Конфигурация системы
└── errors.go         # Централизованная обработка ошибок
```

## Подробное описание компонентов

### server.go - Сердце веб-сервера

Этот файл содержит основную логику HTTP сервера, построенного на Echo Framework. Представьте Echo как высокопроизводительный каркас, который обрабатывает входящие HTTP запросы и направляет их к соответствующим обработчикам.

```go
// Основные функции server.go:
type Server struct {
    echo     *echo.Echo          // Экземпляр Echo фреймворка
    config   *Config             // Конфигурация сервера
    db       *Database           // Подключение к базе данных
    wsHub    *WebSocketHub       // Менеджер WebSocket соединений
}

// InitServer инициализирует сервер с поддержкой HTTP/2
func (s *Server) InitServer() error {
    // Настройка Echo с оптимизированными параметрами
    // Включение HTTP/2 поддержки
    // Настройка лимитов и таймаутов
    // Регистрация middleware цепочки
}
```

Сервер работает исключительно по HTTP на порту 5000, что упрощает развертывание в изолированных сетевых средах, типичных для SBC устройств. Отсутствие HTTPS обусловлено тем, что управление осуществляется в локальной сети, где безопасность обеспечивается на уровне сетевой инфраструктуры.

### websocket.go - Real-time коммуникация

WebSocket соединения критически важны для современного пользовательского интерфейса, особенно при управлении сетевым оборудованием, где состояние может изменяться в реальном времени.

```go
type WebSocketHub struct {
    clients    map[*WebSocketClient]bool    // Активные клиенты
    broadcast  chan []byte                  // Канал для рассылки сообщений
    register   chan *WebSocketClient        // Регистрация новых клиентов  
    unregister chan *WebSocketClient        // Отключение клиентов
    mutex      sync.RWMutex                 // Защита от гонки данных
}

// BroadcastNetworkUpdate отправляет обновления состояния сети всем клиентам
func (h *WebSocketHub) BroadcastNetworkUpdate(data interface{}) {
    // Сериализация данных в JSON
    // Отправка всем подключенным клиентам
    // Обработка отключенных соединений
}
```

WebSocket Hub работает как центральный диспетчер, который получает события от различных сервисов системы (например, изменение состояния сетевого интерфейса) и транслирует их всем подключенным веб-клиентам. Это обеспечивает мгновенное обновление интерфейса без необходимости постоянного опроса сервера.

### auth.go - Система безопасности

Аутентификация построена на принципе хеширования паролей с использованием современных криптографических алгоритмов. Система должна перейти от открытого пароля "sbc:sbc" к безопасному хешированию.

```go
type AuthManager struct {
    db           *Database
    sessionStore map[string]*Session    // Хранилище активных сессий
    hashCost     int                    // Стоимость bcrypt хеширования
}

// HashPassword создает безопасный хеш пароля
func (a *AuthManager) HashPassword(password string) (string, error) {
    // Использование bcrypt с настраиваемой стоимостью
    // Возврат хеша, пригодного для хранения в БД
}

// ValidateSession проверяет активность пользовательской сессии
func (a *AuthManager) ValidateSession(sessionID string) (*User, error) {
    // Проверка существования сессии
    // Валидация времени жизни
    // Возврат информации о пользователе
}
```

Система сессий работает через HTTP cookies, что обеспечивает удобство использования при сохранении безопасности. Каждая сессия имеет ограниченное время жизни и автоматически продлевается при активности пользователя.

### database.go - Управление данными

SQLite выбрана как встроенная база данных, что идеально подходит для SBC устройств, где важна автономность и минимальное потребление ресурсов.

```go
type Database struct {
    conn     *sql.DB           // Подключение к SQLite
    migrations []Migration     // Схема миграций
    mu       sync.RWMutex     // Защита от конкурентного доступа
}

// InitDatabase инициализирует базу данных и выполняет миграции
func (d *Database) InitDatabase() error {
    // Создание подключения к routersbc.sqlitedb
    // Выполнение миграций схемы
    // Создание административного пользователя sbc:sbc
    // Индексирование критических таблиц
}
```

База данных содержит таблицы для пользователей, сессий, конфигураций сетевых интерфейсов, правил фаервола и системных настроек. Все операции выполняются через подготовленные запросы для предотвращения SQL-инъекций.

### loader.go - Автозагрузчик модулей

Автозагрузчик представляет собой один из самых элегантных компонентов системы. Он сканирует директории `handlers`, `routes` и `services`, автоматически обнаруживая и регистрируя новые модули.

```go
type ModuleLoader struct {
    server     *Server
    loadedModules map[string]bool    // Реестр загруженных модулей
}

// AutoLoadHandlers сканирует директорию handlers/ и регистрирует обработчики
func (l *ModuleLoader) AutoLoadHandlers() error {
    // Сканирование директории handlers/
    // Поиск файлов с интерфейсом Handler
    // Автоматическая регистрация найденных обработчиков
    // Логирование процесса загрузки
}

// AutoLoadRoutes регистрирует маршруты из директории routes/
func (l *ModuleLoader) AutoLoadRoutes() error {
    // Поиск файлов route_*.go
    // Извлечение определений маршрутов
    // Связывание маршрутов с обработчиками
}
```

Такой подход означает, что разработчики могут просто добавить новый файл в соответствующую директорию, и система автоматически его подхватит при следующем запуске. Это кардинально упрощает разработку и поддержку модульной архитектуры.

### middleware.go - Цепочка обработки

Middleware представляют собой промежуточные обработчики, которые выполняются до или после основной логики обработки запроса. Они работают как фильтры в конвейере обработки.

```go
// Основные middleware компоненты:

// LoggerMiddleware логирует все HTTP запросы
func LoggerMiddleware() echo.MiddlewareFunc {
    // Логирование метода, URL, времени выполнения
    // Запись ошибок и статус кодов
}

// AuthMiddleware проверяет аутентификацию для защищенных маршрутов  
func AuthMiddleware(auth *AuthManager) echo.MiddlewareFunc {
    // Проверка наличия сессии
    // Валидация прав доступа
    // Перенаправление на страницу входа при необходимости
}

// CORSMiddleware настраивает политики безопасности
func CORSMiddleware() echo.MiddlewareFunc {
    // Настройка заголовков CORS
    // Ограничение доступных методов
}
```

### config.go - Конфигурационный менеджер

Конфигурация системы должна быть гибкой и легко изменяемой без перекомпиляции приложения.

```go
type Config struct {
    Server   ServerConfig   `json:"server"`
    Database DatabaseConfig `json:"database"`  
    Auth     AuthConfig     `json:"auth"`
    Network  NetworkConfig  `json:"network"`
}

type ServerConfig struct {
    Port            int    `json:"port" default:"5000"`
    ReadTimeout     int    `json:"read_timeout" default:"30"`
    WriteTimeout    int    `json:"write_timeout" default:"30"`
    MaxConnections  int    `json:"max_connections" default:"1000"`
}
```

### errors.go - Централизованная обработка ошибок

Правильная обработка ошибок критически важна для стабильности системы управления сетевым оборудованием.

```go
type ErrorHandler struct {
    logger *log.Logger
}

// HandleError централизованно обрабатывает все ошибки приложения
func (e *ErrorHandler) HandleError(err error, context echo.Context) {
    // Логирование ошибки с контекстом
    // Определение типа ошибки
    // Возврат соответствующего HTTP статуса
    // Рендеринг страницы ошибки (404.html, 501.html)
}

// Custom404Handler обслуживает страницы не найденных ресурсов
func (e *ErrorHandler) Custom404Handler(c echo.Context) error {
    // Рендеринг templates/404.html
    // Логирование попытки доступа
}
```

## Жизненный цикл приложения

При запуске приложения происходит следующая последовательность инициализации:

1. **Загрузка конфигурации**: Чтение параметров из файла конфигурации или переменных окружения
2. **Инициализация базы данных**: Подключение к SQLite, выполнение миграций, создание начальных данных
3. **Запуск WebSocket Hub**: Создание горутины для управления real-time соединениями
4. **Создание Echo сервера**: Настройка HTTP сервера с оптимизированными параметрами
5. **Регистрация middleware**: Добавление промежуточных обработчиков в цепочку
6. **Автозагрузка модулей**: Сканирование и регистрация handlers, routes, services
7. **Запуск HTTP сервера**: Начало прослушивания порта 5000

## Интеграция с остальной системой

Модуль `core` предоставляет интерфейсы для взаимодействия с другими компонентами:

- **Handlers** получают доступ к базе данных и WebSocket Hub через внедрение зависимостей
- **Services** используют конфигурационные параметры и логгер из core модуля  
- **Utils/configurators** взаимодействуют с core для получения системной информации
- **Templates** получают данные через handlers, которые обращаются к core сервисам

Такая архитектура обеспечивает слабую связанность компонентов при сохранении централизованного управления ресурсами и конфигурацией. Это позволяет легко тестировать отдельные модули и масштабировать систему по мере необходимости.
