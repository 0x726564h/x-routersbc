# Handlers - Детальное описание

Handlers представляет собой слой обработки HTTP-запросов в архитектуре вашего роутера SBC. Думайте о handlers как о "переводчиках" между веб-интерфейсом пользователя и системными операциями роутера. Каждый handler получает HTTP-запрос, понимает что хочет пользователь, вызывает нужные системные операции через services, и возвращает ответ в понятном для браузера формате.

## Архитектурная роль Handlers

В контексте Echo Framework handlers выполняют роль controller'ов в MVC-паттерне. Они принимают echo.Context (содержащий HTTP-запрос и методы для ответа), обрабатывают бизнес-логику через вызовы services, и формируют HTTP-ответ. Важно понимать, что handlers не должны содержать сложную бизнес-логику - это задача services. Handlers фокусируются на HTTP-специфичных операциях: валидации входных данных, маршалинге JSON, обработке ошибок HTTP, и формировании правильных HTTP-ответов.

## Структура файлов handlers

Каждый handler организован по функциональным доменам вашего роутера. Рассмотрим детально каждый компонент:

### auth_handler.go
Этот файл отвечает за аутентификацию пользователей и управление сессиями. Handler содержит методы для обработки входа в систему, выхода, проверки прав доступа и валидации токенов. Например, функция LoginHandler принимает credentials от пользователя, проверяет их через auth service (который сравнивает с хешированным паролем в SQLite), создает сессию и возвращает соответствующий ответ. Важно, что здесь обрабатываются как обычные HTTP-запросы для веб-интерфейса, так и API-запросы для REST API v1.

```go
// Пример структуры auth_handler.go
func LoginHandler(c echo.Context) error {
    // Получаем данные из формы или JSON
    var loginData LoginRequest
    if err := c.Bind(&loginData); err != nil {
        return echo.NewHTTPError(http.StatusBadRequest, "Неверный формат данных для входа")
    }
    
    // Валидируем входные данные
    if err := validateLoginData(loginData); err != nil {
        return echo.NewHTTPError(http.StatusBadRequest, err.Error())
    }
    
    // Вызываем service для проверки учетных данных
    user, err := authService.AuthenticateUser(loginData.Username, loginData.Password)
    if err != nil {
        return echo.NewHTTPError(http.StatusUnauthorized, "Неверные учетные данные")
    }
    
    // Создаем сессию
    session, err := sessionService.CreateSession(user.ID)
    if err != nil {
        return echo.NewHTTPError(http.StatusInternalServerError, "Ошибка создания сессии")
    }
    
    // Возвращаем успешный ответ
    return c.JSON(http.StatusOK, LoginResponse{Token: session.Token, User: user})
}
```

### network_interfaces_handler.go
Обрабатывает все операции с сетевыми интерфейсами роутера. Здесь реализованы handlers для получения списка интерфейсов, создания новых (VLAN, bridge, VPN), изменения конфигурации существующих, и удаления интерфейсов. Handler должен понимать различные типы интерфейсов: физические (eth, wlan), виртуальные (VLAN, bridge), и VPN-туннели (WireGuard, PPP, PPTP). Каждый тип требует специфичной валидации параметров и различных системных вызовов через services.

Например, при создании VLAN-интерфейса handler должен проверить, что родительский интерфейс существует, VLAN ID находится в допустимом диапазоне (1-4094), и такой VLAN еще не создан. После валидации handler передает управление network service, который создает конфигурацию через соответствующий configurator.

### network_wan_handler.go
Специализируется на конфигурации WAN-подключений. Обрабатывает настройки основного WAN-интерфейса, Multi-WAN для балансировки нагрузки, и специфичные WAN-настройки как MTU, DNS-серверы, и параметры подключения. Handler должен понимать различия между проводным и беспроводным WAN, и обеспечивать корректную валидацию для каждого типа.

Критически важный момент здесь - обработка переключения WAN-интерфейсов без потери связи с роутером. Handler должен координировать с services последовательность операций: подготовка нового интерфейса, тестирование связности, переключение маршрутизации, и откат в случае проблем.

### network_lan_handler.go
Управляет конфигурацией локальной сети. Обрабатывает настройки DHCP-сервера (включая резервирования адресов, диапазоны выдачи, время аренды), DNS-настройки (прокси, форвардинг, локальные зоны), и bridge-конфигурации для объединения интерфейсов.

Особенность этого handler'а в том, что изменения LAN-настроек могут повлиять на доступность веб-интерфейса управления. Handler должен предупреждать пользователя о возможной потере связи и предлагать механизмы восстановления доступа.

### network_wireless_handler.go
Обрабатывает все аспекты беспроводных подключений. Включает конфигурацию Access Point (настройки SSID, шифрования, каналов), Station mode для подключения к внешним Wi-Fi сетям, ADHOC для mesh-сетей, и MONITOR mode для анализа трафика.

Handler должен работать с различными беспроводными адаптерами и их capabilities. Например, не все адаптеры поддерживают одновременную работу в AP и STA режимах. Handler через services должен проверять возможности конкретного оборудования и предоставлять пользователю только доступные опции.

### network_routing_handler.go
Управляет таблицами маршрутизации и связанными сервисами. Обрабатывает создание статических маршрутов, конфигурацию UPnP IGD для автоматического проброса портов, и PCP (Port Control Protocol) для современных NAT-операций.

Handler должен валидировать маршруты на корректность (проверка доступности gateway, отсутствие конфликтующих маршрутов) и предупреждать о потенциальных проблемах с connectivity. Особое внимание требует обработка изменений маршрута по умолчанию - это может привести к потере доступа к роутеру.

### network_firewall_handler.go
Один из наиболее сложных handlers, управляющий правилами фаервола. Должен поддерживать два backend'а: современный NFTables и legacy IPTables. Handler определяет активный backend и загружает соответствующий шаблон (firewall_new.html или firewall_classic.html).

Handler обрабатывает создание и модификацию правил, управление chains (цепочками правил), настройку NAT, и конфигурацию port forwarding. Критически важна валидация правил фаервола - некорректное правило может заблокировать доступ к роутеру или создать бреши в безопасности.

### dashboard_handler.go
Предоставляет агрегированную информацию о состоянии системы. Собирает данные от различных services: статистику интерфейсов, состояние системы, активные подключения, использование ресурсов. Handler оптимизирован для частых обновлений через WebSocket для предоставления real-time мониторинга.

### modal_handler.go
Специализированный handler для обработки модальных диалогов. Обрабатывает AJAX-запросы для динамической загрузки форм конфигурации, валидации данных в real-time, и применения изменений без перезагрузки страницы.

Handler должен возвращать фрагменты HTML для вставки в модальные окна, а также JSON-ответы для обновления состояния интерфейса после применения изменений.

## WebSocket Handlers

Отдельная категория handlers обрабатывает WebSocket-соединения для real-time обновлений интерфейса. Эти handlers поддерживают постоянные соединения с клиентами и рассылают обновления о:

- Изменениях статуса интерфейсов
- Обновлениях конфигурации
- Системных событиях и логах
- Прогрессе выполнения длительных операций

## Валидация и обработка ошибок

Каждый handler реализует многоуровневую валидацию входных данных. Первый уровень - структурная валидация (корректность JSON, наличие обязательных полей). Второй уровень - бизнес-валидация (допустимые значения, отсутствие конфликтов). Третий уровень - системная валидация (доступность ресурсов, права доступа).

Обработка ошибок следует принципам fail-fast и предоставления понятных сообщений пользователю. Handler'ы используют структурированные ошибки с кодами и описаниями, что позволяет фронтенду корректно отображать проблемы пользователю.

## Интеграция с Services

Handler'ы не выполняют системные операции напрямую, а всегда обращаются к соответствующим services. Это обеспечивает разделение ответственности: handlers фокусируются на HTTP-протоколе, а services - на бизнес-логике и системных операциях.

Взаимодействие происходит через четко определенные интерфейсы, что позволяет легко тестировать handlers с mock-services и обеспечивает гибкость архитектуры для будущих изменений.
